/*
 * generated by Xtext 2.13.0
 */
package org.assertx.swing.ui.contentassist

import com.google.inject.Inject
import java.awt.Component
import java.util.List
import javax.swing.JDialog
import javax.swing.JFrame
import org.assertx.swing.assertXSwing.AXSMatcher
import org.assertx.swing.assertXSwing.AXSTestCase
import org.assertx.swing.assertXSwing.AssertXSwingPackage
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.jface.text.contentassist.ICompletionProposal
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.common.types.JvmType
import org.eclipse.xtext.common.types.access.IJvmTypeProvider
import org.eclipse.xtext.common.types.xtext.ui.ITypesProposalProvider.Filter
import org.eclipse.xtext.common.types.xtext.ui.TypeMatchFilters
import org.eclipse.xtext.common.types.xtext.ui.TypeMatchFilters.AbstractFilter
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.ui.editor.contentassist.ReplacementTextApplier

import static extension org.assertx.swing.util.AssertXSwingStaticExtensions.*
import org.eclipse.xtext.common.types.TypesPackage

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class AssertXSwingProposalProvider extends AbstractAssertXSwingProposalProvider {

	@Inject IJvmTypeProvider.Factory typeProviderFactory

	override void completeJvmParameterizedTypeReference_Type(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {

		switch (model) {
			AXSTestCase: {
				// filter off some classes used internally by swing, like print dialog, and one used 
				// by AssertJ Swing to test applets in a JFrame, which cannot be accessed or instantiated and would
				// result in invalid Java code generation
				val AbstractFilter filter = [
					// $1 is an array of char, representing the complete name of the package
					val packName = $1.join
					!packName.startsWith('sun.print') && !packName.startsWith('sun.awt.im') &&
						!packName.startsWith('org.assertj.')
				]
				val typeProvider = typeProviderFactory.createTypeProvider(model.eResource.resourceSet)

				val jFrameType = typeProvider.findTypeByName(JFrame.name)
				createSubTypeProposal(jFrameType, context, AssertXSwingPackage.eINSTANCE.AXSDefinable_TypeRef,
					acceptor, filter)

				val jDialogType = typeProvider.findTypeByName(JDialog.name)
				createSubTypeProposal(jDialogType, context, AssertXSwingPackage.eINSTANCE.AXSDefinable_TypeRef,
					acceptor, filter)
			}
			AXSMatcher: {
				val typeProvider = typeProviderFactory.createTypeProvider(model.eResource.resourceSet)

				val awtComponentType = typeProvider.findTypeByName(Component.name)
				createSubTypeProposal(awtComponentType, context, AssertXSwingPackage.eINSTANCE.AXSDefinable_TypeRef,
					acceptor)
			}
			default:
				super.completeJvmParameterizedTypeReference_Type(model, assignment, context, acceptor)
		}
	}

	override void completeXBlockExpression_Expressions(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {

		super.completeXBlockExpression_Expressions(model, assignment, context, new FeatureCallDelegate(acceptor, model))
	}

	override void completeXFeatureCall_Feature(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {

		super.completeXFeatureCall_Feature(model, assignment, context, new FeatureCallDelegate(acceptor, model))
	}

	override void completeXMemberFeatureCall_Feature(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {

		super.completeXMemberFeatureCall_Feature(model, assignment, context, new FeatureCallDelegate(acceptor, model))
	}

	private def void createSubTypeProposal(JvmType jvmType, ContentAssistContext context, EReference reference,
		ICompletionProposalAcceptor acceptor, Filter... additionalFilters) {

		val filters = newArrayList(TypeMatchFilters.public, TypeMatchFilters.canInstantiate,
			TypeMatchFilters.acceptableByPreference)
		filters += additionalFilters

		typesProposalProvider.createSubTypeProposals(
			jvmType,
			this,
			context,
			TypesPackage.eINSTANCE.jvmParameterizedTypeReference_Type,
			TypeMatchFilters.and(filters),
			acceptor
		)
	}

	static class FeatureCallDelegate extends ICompletionProposalAcceptor.Delegate {

		val List<String> generatedMethods

		new(ICompletionProposalAcceptor delegate, EObject model) {
			super(delegate)
			val testCase = EcoreUtil2.getContainerOfType(model, AXSTestCase)
			generatedMethods = testCase.generatedMethodsNames
		}

		override accept(ICompletionProposal prop) {

			if(prop === null) return

			var proposed = if (prop instanceof ConfigurableCompletionProposal) {
					val textApplier = prop.textApplier
					if (textApplier instanceof ReplacementTextApplier) {
						textApplier.getActualReplacementString(prop)
					} else {
						prop.replacementString
					}
				} else {
					prop.displayString
				}
			// filter out the methods generated by the inferrer
			if (!generatedMethods.contains(proposed)) {
				super.accept(prop)
			}
		}
	}
}
