/*
 * generated by Xtext 2.13.0
 */
package org.assertx.swing.jvmmodel

import com.google.inject.Inject
import org.assertj.swing.core.BasicRobot
import org.assertj.swing.core.GenericTypeMatcher
import org.assertj.swing.core.Robot
import org.assertj.swing.core.Settings
import org.assertj.swing.edt.FailOnThreadViolationRepaintManager
import org.assertj.swing.edt.GuiActionRunner
import org.assertx.swing.AssertXSwingUtils
import org.assertx.swing.assertXSwing.AXSTestCase
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmVisibility
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.junit.After
import org.junit.Before
import org.junit.BeforeClass
import org.junit.Test

import static extension org.assertx.swing.AssertXSwingStaticExtensions.*

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class AssertXSwingJvmModelInferrer extends AbstractModelInferrer {

	public static val BEFORE_CLASS_METHOD_NAME = '_beforeClass'
	public static val BEFORE_METHOD_NAME = '_setup'
	public static val AFTER_METHOD_NAME = '_cleanUp'
	public static val SETTINGS_METHOD_NAME = '_customizeSettings'

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	@Inject extension AssertXSwingUtils

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(AXSTestCase element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		// Here you explain how your model is mapped to Java elements, by writing the actual translation code.
		val testedClass = element?.testedTypeRef?.type
		val testingClassName = element.eResource.URI.trimFileExtension.lastSegment.toFirstUpper
		val fixtureType = element.fieldType

		acceptor.accept(element.toClass(testingClassName)) [
			members += element.toField(element.checkedFieldName, typeRef(fixtureType))
			members += element.toMethod(BEFORE_CLASS_METHOD_NAME, typeRef(Void.TYPE)) [
				annotations += annotationRef(BeforeClass)
				static = true
				body = '''«typeRef(FailOnThreadViolationRepaintManager)».install();'''
			]

			generateSettingsMethod(element)

			members += element.toMethod(BEFORE_METHOD_NAME, typeRef(Void.TYPE)) [
				annotations += annotationRef(Before)
				body = '''
					«IF element.settings !== null»
						«typeRef(Robot)» robot = «typeRef(BasicRobot)».robotWithCurrentAwtHierarchy();
						this.«SETTINGS_METHOD_NAME»(robot.settings());
					«ENDIF»
					«typeRef(testedClass)» frame = «typeRef(GuiActionRunner)».execute(() -> new «typeRef(testedClass)»());
					this.«element.checkedFieldName» = new «typeRef(fixtureType)»(«if(element.settings !== null) 'robot, ' else ''»frame);
				'''
			]

			members += element.toMethod(AFTER_METHOD_NAME, typeRef(Void.TYPE)) [
				annotations += annotationRef(After)
				body = '''
					this.«element.checkedFieldName».cleanUp();
				'''
			]

			for (matcher : element.matchers) {
				members += matcher.toClass(matcher.typeName) [
//						static = true
					superTypes += typeRef(GenericTypeMatcher, matcher.type)
					members += matcher.toConstructor [
						body = '''super(«typeRef(matcher.type.type)».class);'''
					]

					val expression = matcher.matchingExpression
					members += expression.toMethod('isMatching', typeRef('boolean')) [
						annotations += annotationRef(Override)
						parameters += expression.toParameter('it', matcher.type)
						body = expression
					]
				]
			}

			val methodsNames = element.camelCaseMethodsNamesMappings
			for (test : element.tests) {
				val methodName = methodsNames.get(test)
				val theClass = it
				val matchers = test.matchers
				if (matchers.size > 0) {
					members +=
						test.toMethod(methodsNames.getAutogeneratedMethodNameForMatcher(test), typeRef(Void.TYPE)) [
							annotations += annotationRef(Test)

							body = '''
								«FOR matcherRef : matchers»«matcherRef.typeName» «matcherRef.actualVariableName» = new «matcherRef.typeName»();
								«ENDFOR»
								this.«methodName»(«matchers.map[actualVariableName].join(', ')»);
							'''

							theClass.members += test.toMethod(methodName, typeRef(Void.TYPE)) [
								visibility = JvmVisibility.PRIVATE
								for (matcherRef : matchers) {
									parameters +=
										matcherRef.reference.toParameter(matcherRef.checkedVariableName,
											typeRef(matcherRef.typeName))
								}

								body = test.block
							]
						]
				} else {
					members += test.toMethod(methodName, typeRef(Void.TYPE)) [
						annotations += annotationRef(Test)
						body = test.block
					]
				}
			}
		]
	}

	def private generateSettingsMethod(JvmGenericType it, AXSTestCase tc) {
		val settings = tc.settings
		if (settings !== null) {
			members += settings.toMethod(SETTINGS_METHOD_NAME, typeRef(Void.TYPE)) [
				visibility = JvmVisibility.PRIVATE
				parameters += settings.toParameter('it', typeRef(Settings))
				body = settings.block
			]
		}
	}
}
