/*
 * generated by Xtext 2.13.0
 */
package org.assertx.swing.jvmmodel

import com.google.inject.Inject
import org.assertj.swing.core.BasicRobot
import org.assertj.swing.core.GenericTypeMatcher
import org.assertj.swing.core.Robot
import org.assertj.swing.core.Settings
import org.assertj.swing.edt.FailOnThreadViolationRepaintManager
import org.assertj.swing.edt.GuiActionRunner
import org.assertx.swing.assertXSwing.AXSMatcher
import org.assertx.swing.assertXSwing.AXSTestCase
import org.assertx.swing.util.AssertXSwingUtils
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmVisibility
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.junit.After
import org.junit.Before
import org.junit.BeforeClass
import org.junit.Test

import static extension org.assertx.swing.util.AssertXSwingStaticExtensions.*

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class AssertXSwingJvmModelInferrer extends AbstractModelInferrer {

	public static val BEFORE_CLASS_METHOD_NAME = '_beforeClass'
	public static val BEFORE_METHOD_NAME = '_setup'
	public static val AFTER_METHOD_NAME = '_cleanUp'
	public static val SETTINGS_METHOD_NAME = '_customizeSettings'

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	@Inject extension AssertXSwingUtils

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(AXSTestCase element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		// Here you explain how your model is mapped to Java elements, by writing the actual translation code.
		val testedClass = element?.getTypeRef?.type
		val fixtureType = element.fieldType

		acceptor.accept(element.toClass(element.qualifiedName)) [
			packageName = element.package
			members += element.toField(element.checkedFieldName, typeRef(fixtureType))
			members += element.toMethod(BEFORE_CLASS_METHOD_NAME, typeRef(Void.TYPE)) [
				annotations += annotationRef(BeforeClass)
				static = true
				body = '''«typeRef(FailOnThreadViolationRepaintManager)».install();'''
			]

			generateSettingsMethod(element)

			members += element.toMethod(BEFORE_METHOD_NAME, typeRef(Void.TYPE)) [
				annotations += annotationRef(Before)
				body = '''
					«IF element.settings !== null»
						«typeRef(Robot)» robot = «typeRef(BasicRobot)».robotWithCurrentAwtHierarchy();
						this.«SETTINGS_METHOD_NAME»(robot.settings());
					«ENDIF»
					«typeRef(testedClass)» frame = «typeRef(GuiActionRunner)».execute(() -> new «typeRef(testedClass)»());
					«element.toFieldSelectionStatement» = new «typeRef(fixtureType)»(«if(element.settings !== null) 'robot, ' else ''»frame);
				'''
			]

			members += element.toMethod(AFTER_METHOD_NAME, typeRef(Void.TYPE)) [
				annotations += annotationRef(After)
				body = '''
					«element.toFieldSelectionStatement».cleanUp();
				'''
			]

			for (matcher : element.matchers) {
				members += matcher.generateWithVisibility(JvmVisibility.PRIVATE)
			}

			val methodsNames = element.camelCaseMethodsNamesMappings
			for (test : element.tests) {
				val methodName = methodsNames.get(test)
				members += test.toMethod(methodName, typeRef(Void.TYPE)) [
					annotations += annotationRef(Test)
					body = test.block
				]
			}
		]
	}

	def dispatch void infer(AXSMatcher element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(element.generateWithVisibility(JvmVisibility.DEFAULT))
	}

	def generateWithVisibility(AXSMatcher matcher, JvmVisibility visib) {
		matcher.toClass(matcher.typeName) [
			packageName = matcher.package
			visibility = visib
			superTypes += typeRef(GenericTypeMatcher, matcher.getTypeRef)
			members += matcher.toConstructor [
				body = '''super(«matcher.getTypeRef».class);'''
			]

			val expression = matcher.matchingExpression
			members += expression.toMethod('isMatching', typeRef('boolean')) [
				annotations += annotationRef(Override)
				parameters += expression.toParameter('it', matcher.getTypeRef)
				body = expression
			]
		]
	}

	def private generateSettingsMethod(JvmGenericType it, AXSTestCase tc) {
		val settings = tc.settings
		if (settings !== null) {
			members += settings.toMethod(SETTINGS_METHOD_NAME, typeRef(Void.TYPE)) [
				visibility = JvmVisibility.PRIVATE
				parameters += settings.toParameter('it', typeRef(Settings))
				body = settings.block
			]
		}
	}

	def private toFieldSelectionStatement(AXSTestCase tc) {
		'this.' + tc.checkedFieldName
	}
}
