/*
 * generated by Xtext 2.13.0
 */
package org.assertx.swing.validation

import com.google.common.collect.HashMultimap
import java.awt.Component
import javax.swing.JDialog
import javax.swing.JFrame
import org.assertx.swing.assertXSwing.AXSMatcher
import org.assertx.swing.assertXSwing.AXSSettings
import org.assertx.swing.assertXSwing.AXSTestCase
import org.assertx.swing.assertXSwing.AXSTestMethod
import org.assertx.swing.assertXSwing.AssertXSwingPackage
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.XAbstractFeatureCall
import org.eclipse.xtext.xbase.XBlockExpression
import org.eclipse.xtext.xbase.XbasePackage

import static extension org.assertx.swing.AssertXSwingStaticExtensions.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AssertXSwingValidator extends AbstractAssertXSwingValidator {

	static val ISSUE_CODE_PREFIX = 'org.assertx.swing.'
	public static val SAME_NAME_METHODS = ISSUE_CODE_PREFIX + 'SameNameMethods'
	public static val UNTESTABLE_TYPE = ISSUE_CODE_PREFIX + 'UntestableType'
	public static val NULL_METHOD_NAME = ISSUE_CODE_PREFIX + 'NullMethodName'
	public static val AUTOGENERATED_METHOD_ACCESSED = ISSUE_CODE_PREFIX + 'AutogeneratedMethodAccessed'
	public static val EMPTY_SETTINGS_SECTION = ISSUE_CODE_PREFIX + 'EmptySettingsSection'
	public static val EMPTY_METHOD_NAME = ISSUE_CODE_PREFIX + 'EmptyMEthodName'
	public static val TOO_MANY_SETTINGS = ISSUE_CODE_PREFIX + 'TooManySettings'
	public static val UNMATCHABLE_TYPE = ISSUE_CODE_PREFIX + 'IncompatibleMatchingType'

	@Check
	def void checkMethodNamesAreUnique(AXSTestCase tc) {
		val tests = HashMultimap.create

		for (test : tc.tests)
			tests.put(test.name, test)

		for (e : tests.asMap.entrySet) {
			val collisions = e.value
			if (collisions.size > 1) {
				for (c : collisions) {
					warning(
						"Duplicate test method '" + c.name +
							"': test methods should use different and explanatory names",
						c,
						AssertXSwingPackage.eINSTANCE.AXSTestMethod_Name,
						SAME_NAME_METHODS
					)
				}
			}
		}
	}

	@Check
	def void checkTestedClassMustBeSubclassOfJFrameOrJDialog(AXSTestCase tc) {
		val clazz = tc.testedTypeRef.toLightweightTypeReference
		if (!(clazz.isSubtypeOf(JFrame) || clazz.isSubtypeOf(JDialog)))
			error(
				"Untestable type: the class under test must be a subclass of either 'javax.swing.JFrame' or 'javax.swing.JDialog'",
				AssertXSwingPackage.eINSTANCE.AXSTestCase_TestedTypeRef, UNTESTABLE_TYPE)
	}

	@Check
	def void checkAutogeneratedMethodsAccess(XAbstractFeatureCall featureCall) {
		val name = featureCall.feature.simpleName
		val testCase = EcoreUtil2.getContainerOfType(featureCall, AXSTestCase)
		val autogeneratedNames = testCase.getGeneratedMethodsNames
		if (autogeneratedNames.contains(name)) {
			error(
				'The method "' + name +
					'" is autogenerated from other parts of the test case definition and it is part of a fixed workflow. You cannot call it',
				featureCall,
				XbasePackage.eINSTANCE.XAbstractFeatureCall_Feature,
				AUTOGENERATED_METHOD_ACCESSED
			)
		}
	}

	@Check
	def void checkSettingsSection(AXSSettings s) {
		if ((s.block as XBlockExpression).expressions.empty) {
			warning(
				'You should avoid declaring an empty settings section in your test case definition',
				s,
				null,
				EMPTY_SETTINGS_SECTION
			)
		}
	}

	@Check
	def void checkMethodNameIsNotAnEmptyString(AXSTestMethod m) {
		if (m.name == '') {
			warning(
				'You should really give your test methods a name, maybe even an explanatory one',
				m,
				AssertXSwingPackage.eINSTANCE.AXSTestMethod_Name,
				EMPTY_METHOD_NAME
			)
		}
	}

	@Check
	def void checkTherIsOnlyOneSettingsDefinition(AXSTestCase tc) {
		val definedSettings = tc.members.filter(AXSSettings)
		if (definedSettings.size > 1) {
			for (settings : definedSettings) {
				error(
					'Too many settings definition! Settings are defined multiple times, but only one such definition is allowed',
					settings,
					null,
					TOO_MANY_SETTINGS
				)
			}
		}
	}

	@Check
	def void checkMatchingTypeInMatcher(AXSMatcher m) {
		val type = m.type.toLightweightTypeReference
		if (!type.isSubtypeOf(Component)) {
			error(
				'Unmatchable type: the type "' + m.type.qualifiedName +
					'" is not suitable for a matcher definition, only subtypes of "' +
					Component.canonicalName + '" can be matched',
				m,
				AssertXSwingPackage.eINSTANCE.AXSMatcher_Type,
				UNMATCHABLE_TYPE
			)
		}
	}
}
