/*
 * generated by Xtext 2.13.0
 */
package org.assertx.swing.validation

import com.google.common.collect.HashMultimap
import java.awt.Component
import javax.swing.JDialog
import javax.swing.JFrame
import org.assertx.swing.assertXSwing.AXSMatcher
import org.assertx.swing.assertXSwing.AXSMembers
import org.assertx.swing.assertXSwing.AXSSettings
import org.assertx.swing.assertXSwing.AXSTestCase
import org.assertx.swing.assertXSwing.AXSTestMethod
import org.assertx.swing.assertXSwing.AssertXSwingPackage
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.diagnostics.Severity
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.XAbstractFeatureCall
import org.eclipse.xtext.xbase.XBlockExpression
import org.eclipse.xtext.xbase.XbasePackage

import static extension org.assertx.swing.util.AssertXSwingStaticExtensions.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AssertXSwingValidator extends AbstractAssertXSwingValidator {

	static val ISSUE_CODE_PREFIX = 'org.assertx.swing.'
	public static val SAME_NAME_MEMBERS = ISSUE_CODE_PREFIX + 'SameNameMembers'
	public static val UNTESTABLE_TYPE = ISSUE_CODE_PREFIX + 'UntestableType'
	public static val NULL_METHOD_NAME = ISSUE_CODE_PREFIX + 'NullMethodName'
	public static val AUTOGENERATED_METHOD_ACCESSED = ISSUE_CODE_PREFIX + 'AutogeneratedMethodAccessed'
	public static val EMPTY_SETTINGS_SECTION = ISSUE_CODE_PREFIX + 'EmptySettingsSection'
	public static val EMPTY_METHOD_NAME = ISSUE_CODE_PREFIX + 'EmptyMethodName'
	public static val TOO_MANY_SETTINGS = ISSUE_CODE_PREFIX + 'TooManySettings'
	public static val UNMATCHABLE_TYPE = ISSUE_CODE_PREFIX + 'IncompatibleMatchingType'

	@Check
	def void checkMembersNamesAreUnique(AXSTestCase tc) {
		val tests = HashMultimap.create
		val matchers = HashMultimap.create

		for (member : tc.members) {
			if (member instanceof AXSTestMethod) {
				tests.put(member.name, member)
			} else if (member instanceof AXSMatcher) {
				matchers.put(member.name, member)
			}
		}

		tests.checkDuplicatesAndCreateDiagnostic(
			Severity.WARNING,
			'test method',
			'test methods should use different and explanatory names',
			AssertXSwingPackage.eINSTANCE.AXSTestMethod_Name
		)
		matchers.checkDuplicatesAndCreateDiagnostic(
			Severity.ERROR,
			'matcher',
			'matchers with same name are not permitted',
			AssertXSwingPackage.eINSTANCE.AXSMatcher_Name
		)
	}

	def private void checkDuplicatesAndCreateDiagnostic(HashMultimap<String, AXSMembers> members, Severity severity,
		String memberType, String secondPart, EStructuralFeature feature) {

		for (e : members.asMap.entrySet) {
			val collisions = e.value
			if (collisions.size > 1) {
				for (c : collisions) {
					addAppropriateSeverityDiagnostic(
						severity,
						'''Duplicate «memberType» '«e.key»': «secondPart»''',
						c,
						feature,
						AssertXSwingValidator.SAME_NAME_MEMBERS
					)
				}
			}
		}
	}

	def private void addAppropriateSeverityDiagnostic(Severity severity, String message, EObject object,
		EStructuralFeature feature, String issueCode) {

		if (severity == Severity.ERROR) {
			error(message, object, feature, issueCode)
		} else if (severity == Severity.WARNING) {
			warning(message, object, feature, issueCode)
		}
	}

	@Check
	def void checkTestedClassMustBeSubclassOfJFrameOrJDialog(AXSTestCase tc) {
		val clazz = tc.testedTypeRef.toLightweightTypeReference
		if (!(clazz.isSubtypeOf(JFrame) || clazz.isSubtypeOf(JDialog)))
			error(
				"Untestable type: the class under test must be a subclass of either 'javax.swing.JFrame' or 'javax.swing.JDialog'",
				AssertXSwingPackage.eINSTANCE.AXSTestCase_TestedTypeRef, UNTESTABLE_TYPE)
	}

	@Check
	def void checkAutogeneratedMethodsAccess(XAbstractFeatureCall featureCall) {
		val name = featureCall.feature.simpleName
		val testCase = EcoreUtil2.getContainerOfType(featureCall, AXSTestCase)
		val autogeneratedNames = testCase.getGeneratedMethodsNames
		if (autogeneratedNames.contains(name)) {
			error(
				'The method "' + name +
					'" is autogenerated from other parts of the test case definition and it is part of a fixed workflow. You cannot call it',
				featureCall,
				XbasePackage.eINSTANCE.XAbstractFeatureCall_Feature,
				AUTOGENERATED_METHOD_ACCESSED
			)
		}
	}

	@Check
	def void checkSettingsSection(AXSSettings s) {
		if ((s.block as XBlockExpression).expressions.empty) {
			warning(
				'You should avoid declaring an empty settings section in your test case definition',
				s,
				null,
				EMPTY_SETTINGS_SECTION
			)
		}
	}

	@Check
	def void checkMethodNameIsNotAnEmptyString(AXSTestMethod m) {
		if (m.name == '') {
			warning(
				'You should really give your test methods a name, maybe even an explanatory one',
				m,
				AssertXSwingPackage.eINSTANCE.AXSTestMethod_Name,
				EMPTY_METHOD_NAME
			)
		}
	}

	@Check
	def void checkThereIsOnlyOneSettingsDefinition(AXSTestCase tc) {
		val definedSettings = tc.allSettings
		if (definedSettings.size > 1) {
			for (settings : definedSettings) {
				error(
					'Too many settings definition! Settings are defined multiple times, but only one such definition is allowed',
					settings,
					null,
					TOO_MANY_SETTINGS
				)
			}
		}
	}

	@Check
	def void checkMatchingTypeInMatcher(AXSMatcher m) {
		val type = m.type.toLightweightTypeReference
		if (!type.isSubtypeOf(Component)) {
			error(
				'Unmatchable type: "' + m.type.qualifiedName +
					'" is not suitable for a matcher definition, only subtypes of "' + Component.canonicalName +
					'" can be matched',
				m,
				AssertXSwingPackage.eINSTANCE.AXSMatcher_Type,
				UNMATCHABLE_TYPE
			)
		}
	}
}
