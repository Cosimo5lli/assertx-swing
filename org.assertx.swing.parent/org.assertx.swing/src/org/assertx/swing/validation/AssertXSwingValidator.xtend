/*
 * generated by Xtext 2.13.0
 */
package org.assertx.swing.validation

import com.google.common.collect.HashMultimap
import javax.swing.JDialog
import javax.swing.JFrame
import org.assertx.swing.assertXSwing.AXSSettings
import org.assertx.swing.assertXSwing.AXSTestCase
import org.assertx.swing.assertXSwing.AssertXSwingPackage
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.XAbstractFeatureCall
import org.eclipse.xtext.xbase.XBlockExpression
import org.eclipse.xtext.xbase.XbasePackage

import static extension org.assertx.swing.AssertXSwingStaticExtensions.*
import org.assertx.swing.assertXSwing.AXSTestMethod

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AssertXSwingValidator extends AbstractAssertXSwingValidator {
	
	static val ISSUE_CODE_PREFIX = 'org.assertx.swing.'
	public static val SAME_NAME_METHODS = ISSUE_CODE_PREFIX + 'SameNameMethods'
	public static val UNTESTABLE_TYPE = ISSUE_CODE_PREFIX + 'UntestableType'
	public static val NULL_METHOD_NAME = ISSUE_CODE_PREFIX + 'NullMethodName'
	public static val AUTOGENERATED_METHOD_ACCESSED = ISSUE_CODE_PREFIX + 'AutogeneratedMethodAccessed'
	public static val EMPTY_SETTINGS_SECTION = ISSUE_CODE_PREFIX + 'EmptySettingsSection'
	public static val EMPTY_METHOD_NAME = ISSUE_CODE_PREFIX + 'EmptyMEthodName'
	
	@Check
	def void checkMethodNamesAreUnique(AXSTestCase tc){
		val tests = HashMultimap.create
		
		for (test : tc.tests)
			tests.put(test.name, test)
		
		for (e : tests.asMap.entrySet){
			val collisions = e.value
			if(collisions.size > 1){
				for(c : collisions){
					warning("Duplicate test method '" + c.name + "': test methods should use different and explanatory names",
						c,	AssertXSwingPackage.eINSTANCE.AXSTestMethod_Name,
						SAME_NAME_METHODS
					)
				}
			}
		}
	}
	
	@Check
	def void checkTestedClassMustBeSubclassOfJFrameOrJDialog(AXSTestCase tc){
		val clazz = tc.testedTypeRef.toLightweightTypeReference
		if( !(clazz.isSubtypeOf(JFrame) || clazz.isSubtypeOf(JDialog)) )
			error("Untestable type: the class under test must be a subclass of either 'javax.swing.JFrame' or 'javax.swing.JDialog'",
				AssertXSwingPackage.eINSTANCE.AXSTestCase_TestedTypeRef,
				UNTESTABLE_TYPE	)
	}
	
	@Check
	def void checkAutogeneratedMethodsAccess(XAbstractFeatureCall featureCall){
		val name = featureCall.feature.simpleName
		val testCase = EcoreUtil2.getContainerOfType(featureCall, AXSTestCase)
		val isError = if(testCase !== null) name.isAutogeneratedFrom(testCase) else name.isAutogeneratedMethodName
		if(isError){
			error('The method "' + name + 
				'" is autogenerated from other parts of the test case definition and it is part of a fixed workflow. You cannot call it',
				featureCall, XbasePackage.eINSTANCE.XAbstractFeatureCall_Feature, 
				AUTOGENERATED_METHOD_ACCESSED
			)
		}
	}
	
	@Check
	def void checkSettingsSection(AXSSettings s){
		if((s.block as XBlockExpression).expressions.empty){
			warning('You should avoid declaring an empty settings section in your test case definition',
				s, null, EMPTY_SETTINGS_SECTION
			)
		}
	}
	
	@Check
	def void checkMethodNameIsNotAnEmptyString(AXSTestMethod m){
		if(m.name == ''){
			warning('You should really give your test methods a name, maybe even an explanatory one',
				m, AssertXSwingPackage.eINSTANCE.AXSTestMethod_Name, EMPTY_METHOD_NAME
			)
		}
	}
}
