package org.assertx.swing.tests

import com.google.inject.Inject
import org.assertx.swing.assertXSwing.AXSFile
import org.assertx.swing.assertXSwing.AssertXSwingPackage
import org.assertx.swing.validation.AssertXSwingValidator
import org.eclipse.emf.ecore.EClass
import org.eclipse.xtext.diagnostics.Severity
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.eclipse.xtext.xbase.XbasePackage
import org.eclipse.xtext.xbase.validation.IssueCodes
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(XtextRunner)
@InjectWith(AssertXSwingInjectorProvider)
class AssertXSwingValidationTest {

	@Inject extension ParseHelper<AXSFile>

	@Inject extension ValidationTestHelper

	@Test
	def void testWarningOnMethodWithSameName() {
		val name = "'Good name'"
		'''
			def Test testing «ExampleJFrame.canonicalName» {
			
				test «name» {}
				
				test «name» {}
			}
		'''.assertDuplicate(
			AssertXSwingPackage.eINSTANCE.AXSTestMethod,
			name,
			'Duplicate test method ' + name + ': test methods should use different and explanatory names',
			Severity.WARNING
		)
	}

	@Test
	def void testNoWarningOnMethodsWhichCompilesToSameIdsButHaveDifferentNames() {
		'''
			def Test testing «ExampleJFrame.canonicalName» {
			
				test 'Method 1' {}
				
				test 'method 1' {}
			}
		'''.parse.assertNoErrors
	}

	@Test
	def void testWindowFieldIsAccessibleFromTestMethodBody() {
		'''
			def Test testing «ExampleJFrame.canonicalName» {
			
				test 'm' {
					window.button('copyButton')
				}
			}
		'''.parse.assertNoErrors
	}

	@Test
	def void testCustomFieldIsAccessibleFromTestMethodBody() {
		'''
			def Test testing «ExampleJFrame.canonicalName» as custom {
			
				test 'l' {
					custom.button('copyButton')
				}
			}
		'''.parse.assertNoErrors
	}

	@Test
	def void testClassMustBeSubclassOfJFrameOrJDialog() {
		val wrongClass = 'java.lang.Object'
		val input = '''
			def Test testing «wrongClass»
		'''

		input.parse.assertError(
			AssertXSwingPackage.eINSTANCE.AXSTestCase,
			AssertXSwingValidator.UNTESTABLE_TYPE,
			input.indexOf(wrongClass),
			wrongClass.length,
			"Untestable type: the class under test must be a subclass of either 'javax.swing.JFrame' or 'javax.swing.JDialog'"
		)
	}

	@Test
	def void testCorrectEmptyTestClassIsAccepted() {
		'''
			def Test testing «ExampleJFrame.canonicalName» {}
		'''.parse.assertNoErrors
	}

	@Test
	def void testNullMethodName() {
		'''
			def Test testing «ExampleJFrame.canonicalName» {
			
				test {
					window.button('copyButton')
				}
			}
		'''.parse.assertError(
			XbasePackage.eINSTANCE.XBlockExpression,
			AssertXSwingValidator.NULL_METHOD_NAME,
			'Missing method name after "test" keyword'
		)
	}

	@Test
	def void testAutogeneratedMethodsAreNotAccessible() {
		'''
			def Test testing javax.swing.JFrame {
			
				settings {
					
				}
				
				test 'method 1' {
					_setup()
					_customizeSettings
					_beforeClass
					_cleanUp
				}
			}
		'''.parse => [
			assertAutogeneratedMethod('_setup', XbasePackage.eINSTANCE.XFeatureCall)
			assertAutogeneratedMethod('_customizeSettings', XbasePackage.eINSTANCE.XFeatureCall)
			assertAutogeneratedMethod('_beforeClass', XbasePackage.eINSTANCE.XFeatureCall)
			assertAutogeneratedMethod('_cleanUp', XbasePackage.eINSTANCE.XFeatureCall)
		]
	}

	@Test
	def void testAutogeneratedMethodsAreNotAccessibleInMemberSelections() {
		'''
			def Test testing javax.swing.JDialog {
			
				settings {
					
				}
				
				test 'my method' {
					this._setup
					this._customizeSettings
					this._beforeClass
					this._cleanUp
				}
			}
		'''.parse => [
			assertAutogeneratedMethod('_setup', XbasePackage.eINSTANCE.XMemberFeatureCall)
			assertAutogeneratedMethod('_customizeSettings', XbasePackage.eINSTANCE.XMemberFeatureCall)
			assertAutogeneratedMethod('_beforeClass', XbasePackage.eINSTANCE.XMemberFeatureCall)
			assertAutogeneratedMethod('_cleanUp', XbasePackage.eINSTANCE.XMemberFeatureCall)
		]
	}

	@Test
	def void testNonDeclaredSettingsSectionWontIssueAutogeneratedAccessError() {
		'''
			def Test testing javax.swing.JDialog {
			
				test 'meyhod' {
					_customizeSettings
					this._customizeSettings
				}
			}
		'''.parse.assertNoError(AssertXSwingValidator.AUTOGENERATED_METHOD_ACCESSED)
	}

	@Test
	def void testEmptySettingsSection() {
		'''
		def Test testing javax.swing.JFrame {
		
			settings {
				
			}
		}'''.parse.assertWarning(
			AssertXSwingPackage.eINSTANCE.AXSSettings,
			AssertXSwingValidator.EMPTY_SETTINGS_SECTION,
			'You should avoid declaring an empty settings section in your test case definition'
		)
	}

	@Test
	def void testSingleNonEmptySettingsAreOk() {
		'''
			def Test testing javax.swing.JFrame {
			
				settings {
					delayBetweenEvents(200)
				}
			}
		'''.parse.assertNoIssues
	}

	@Test
	def void testEmptyStringAsMethodNameIssueWarning() {
		val input = '''
			def Test testing javax.swing.JFrame {
			
				test '' {
					
				}
			}
		'''

		input.parse.assertWarning(
			AssertXSwingPackage.eINSTANCE.AXSTestMethod,
			AssertXSwingValidator.EMPTY_METHOD_NAME,
			input.indexOf("'"),
			"''".length,
			'You should really give your test methods a name, maybe even an explanatory one'
		)
	}

	@Test
	def void testMultipleSettingsDefinitionError() {
		val settingsDef = '''
		settings {
			
		}'''

		val input = '''
			def Test testing javax.swing.JFrame {
			
			«settingsDef»
			
			«settingsDef»
			
			}
		'''

		input.parse => [
			assertError(
				AssertXSwingPackage.eINSTANCE.AXSSettings,
				AssertXSwingValidator.TOO_MANY_SETTINGS,
				input.indexOf(settingsDef),
				settingsDef.length,
				'Too many settings definition! Settings are defined multiple times, but only one such definition is allowed'
			)
			assertError(
				AssertXSwingPackage.eINSTANCE.AXSSettings,
				AssertXSwingValidator.TOO_MANY_SETTINGS,
				input.lastIndexOf(settingsDef),
				settingsDef.length,
				'Too many settings definition! Settings are defined multiple times, but only one such definition is allowed'
			)
		]
	}

	@Test
	def void testMatchersMatchingTypeComplyWithGenericTypeMatcherTypeParameterBound() {
		val type = 'Object'

		val input = '''
			def Test testing javax.swing.JFrame {
			
				def aName match «type» {
					true
				}
			}
		'''

		input.parse.assertError(
			AssertXSwingPackage.eINSTANCE.AXSMatcher,
			AssertXSwingValidator.UNMATCHABLE_TYPE,
			input.indexOf(type),
			type.length,
			'Unmatchable type: "java.lang.Object" is not suitable for a matcher definition, only subtypes of "java.awt.Component" can be matched'
		)
	}

	@Test
	def void testErrorOnMatchersWithSameName() {
		val name = 'aName'
		'''
			def Test testing javax.swing.JFrame {
			
				def «name» match javax.swing.JButton {
					true
				}
				
				def «name» match javax.swing.JLabel {
					true
				}
			}
		'''.assertDuplicate(
			AssertXSwingPackage.eINSTANCE.AXSMatcher,
			name,
			"Duplicate matcher '" + name + "': matchers with same name are not permitted within the same test case",
			Severity.ERROR
		)
	}

	@Test
	def void testNoErrorsOnTestMethodAndMatcherWithSameName() {
		'''
			def Test testing javax.swing.JFrame {
			
				def m1 match javax.swing.JLabel {
					true
				}
				
				test 'm1' {
					
				}
			}
		'''.parse.assertNoErrors
	}

	@Test
	def void testXbaseValidatesMatcherRef() {
		val ref = '?matcherName?'

		val input = '''
			def Test testing javax.swing.JFrame {
			
				test 'm1' {
					«ref»
				}
				
				def matcherName match javax.swing.JLabel {
					true
				}
			}
		'''

		input.parse.assertError(
			AssertXSwingPackage.eINSTANCE.AXSMatcherRef,
			IssueCodes.INVALID_INNER_EXPRESSION,
			input.indexOf(ref),
			ref.length,
			"This expression is not allowed in this context, since it doesn't cause any side effects."
		)
	}

	@Test
	def void testErrorOnTestCasesWithSameName() {
		'''
			def Test testing javax.swing.JFrame {}
			def Test testing javax.swing.JDialog{}
		'''.assertDuplicate(
			AssertXSwingPackage.eINSTANCE.AXSTestCase,
			'Test',
			"Duplicate test case 'Test': test cases with same name are not permitted within the same file",
			Severity.ERROR
		)
	}

	@Test
	def void testErrorOnMatchersWithSameNameAtFileLevel() {
		'''
			def prova match javax.swing.JButton {}
			def prova match javax.swing.JLabel{}
		'''.assertDuplicate(
			AssertXSwingPackage.eINSTANCE.AXSMatcher,
			'prova',
			"Duplicate matcher 'prova': matchers with same name are not permitted within the same file",
			Severity.ERROR
		)
	}

	def private void assertDuplicate(CharSequence input, EClass type, String name, String message, Severity severity) {
		input.parse => [
			assertIssue(
				type,
				AssertXSwingValidator.SAME_NAME,
				input.toString.indexOf(name),
				name.length,
				severity,
				message
			)
			assertIssue(
				type,
				AssertXSwingValidator.SAME_NAME,
				input.toString.lastIndexOf(name),
				name.length,
				severity,
				message
			)
		]
	}

	def private void assertAutogeneratedMethod(AXSFile file, String methodName, EClass type) {
		file.assertError(
			type,
			AssertXSwingValidator.AUTOGENERATED_METHOD_ACCESSED,
			'The method "' + methodName +
				'" is autogenerated from other parts of the test case definition and it is part of a fixed workflow. You cannot call it'
		)
	}

}
