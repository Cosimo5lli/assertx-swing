package org.assertx.swing.tests

import com.google.inject.Inject
import org.assertx.swing.assertXSwing.AXSTestCase
import org.assertx.swing.assertXSwing.AssertXSwingPackage
import org.assertx.swing.validation.AssertXSwingValidator
import org.eclipse.emf.ecore.EClass
import org.eclipse.xtext.diagnostics.Severity
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.eclipse.xtext.xbase.XbasePackage
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(XtextRunner)
@InjectWith(AssertXSwingInjectorProvider)
class AssertXSwingValidationTest {

	@Inject extension ParseHelper<AXSTestCase>

	@Inject extension ValidationTestHelper

	@Test
	def void testWarningOnMethodWithSameName() {
		val name = "'Good name'"
		'''
			testing «ExampleJFrame.canonicalName»
			
			test «name» {}
			
			test «name» {}
		'''.assertDuplicate(
			AssertXSwingPackage.eINSTANCE.AXSTestMethod,
			name,
			'Duplicate test method ' + name + ': test methods should use different and explanatory names',
			Severity.WARNING
		)
	}

	@Test
	def void testNoWarningOnMethodsWhichCompilesToSameIdsButHaveDifferentNames() {
		'''
			testing «ExampleJFrame.canonicalName»
			
			test 'Method 1' {}
			
			test 'method 1' {}
		'''.parse.assertNoErrors
	}

	@Test
	def void testWindowFieldIsAccessibleFromTestMethodBody() {
		'''
			testing «ExampleJFrame.canonicalName»
			
			test 'm' {
				window.button('copyButton')
			}
		'''.parse.assertNoErrors
	}

	@Test
	def void testCustomFieldIsAccessibleFromTestMethodBody() {
		'''
			testing «ExampleJFrame.canonicalName» as custom
			
			test 'l' {
				custom.button('copyButton')
			}
		'''.parse.assertNoErrors
	}

	@Test
	def void testClassMustBeSubclassOfJFrameOrJDialog() {
		val wrongClass = 'java.lang.Object'
		val input = '''
			testing «wrongClass»
		'''

		input.parse.assertError(
			AssertXSwingPackage.eINSTANCE.AXSTestCase,
			AssertXSwingValidator.UNTESTABLE_TYPE,
			input.indexOf(wrongClass),
			wrongClass.length,
			"Untestable type: the class under test must be a subclass of either 'javax.swing.JFrame' or 'javax.swing.JDialog'"
		)
	}

	@Test
	def void testCorrectTestClassIsAccepted() {
		'''
			testing «ExampleJFrame.canonicalName»
		'''.parse.assertNoErrors
	}

	@Test
	def void testNullMethodName() {
		'''
			testing «ExampleJFrame.canonicalName»
			
			test {
				window.button('copyButton')
			}
		'''.parse.assertError(
			XbasePackage.eINSTANCE.XBlockExpression,
			AssertXSwingValidator.NULL_METHOD_NAME,
			'Missing method name after "test" keyword'
		)
	}

	@Test
	def void testAutogeneratedMethodsAreNotAccessible() {
		'''
			testing javax.swing.JFrame
			
			settings {
				
			}
			
			test 'method 1' {
				_setup()
				_customizeSettings
				_beforeClass
				_cleanUp
			}
		'''.parse => [
			assertAutogeneratedMethod('_setup', XbasePackage.eINSTANCE.XFeatureCall)
			assertAutogeneratedMethod('_customizeSettings', XbasePackage.eINSTANCE.XFeatureCall)
			assertAutogeneratedMethod('_beforeClass', XbasePackage.eINSTANCE.XFeatureCall)
			assertAutogeneratedMethod('_cleanUp', XbasePackage.eINSTANCE.XFeatureCall)
		]
	}

	@Test
	def void testAutogeneratedMethodsAreNotAccessibleInMemberSelections() {
		'''
			testing javax.swing.JDialog
			
			settings {
				
			}
			
			test 'my method' {
				this._setup
				this._customizeSettings
				this._beforeClass
				this._cleanUp
			}
		'''.parse => [
			assertAutogeneratedMethod('_setup', XbasePackage.eINSTANCE.XMemberFeatureCall)
			assertAutogeneratedMethod('_customizeSettings', XbasePackage.eINSTANCE.XMemberFeatureCall)
			assertAutogeneratedMethod('_beforeClass', XbasePackage.eINSTANCE.XMemberFeatureCall)
			assertAutogeneratedMethod('_cleanUp', XbasePackage.eINSTANCE.XMemberFeatureCall)
		]
	}

	@Test
	def void testNonDeclaredSettingsSectionWontIssueAutogeneratedAccessError() {
		'''
			testing javax.swing.JDialog
			
			test 'meyhod' {
				_customizeSettings
				this._customizeSettings
			}
		'''.parse.assertNoError(AssertXSwingValidator.AUTOGENERATED_METHOD_ACCESSED)
	}

	@Test
	def void testEmptySettingsSection() {
		'''
		testing javax.swing.JFrame
		
		settings {
			
		}'''.parse.assertWarning(
			AssertXSwingPackage.eINSTANCE.AXSSettings,
			AssertXSwingValidator.EMPTY_SETTINGS_SECTION,
			'You should avoid declaring an empty settings section in your test case definition'
		)
	}

	@Test
	def void testSingleNonEmptySettingsAreOk() {
		'''
			testing javax.swing.JFrame
			
			settings {
				delayBetweenEvents(200)
			}
		'''.parse.assertNoIssues
	}

	@Test
	def void testEmptyStringAsMethodNameIssueWarning() {
		val input = '''
			testing javax.swing.JFrame
			
			test '' {
				
			}
		'''

		input.parse.assertWarning(
			AssertXSwingPackage.eINSTANCE.AXSTestMethod,
			AssertXSwingValidator.EMPTY_METHOD_NAME,
			input.indexOf("'"),
			"''".length,
			'You should really give your test methods a name, maybe even an explanatory one'
		)
	}

	@Test
	def void testMultipleSettingsDefinitionError() {
		val settingsDef = '''
		settings {
			
		}'''

		val input = '''
			testing javax.swing.JFrame
			
			«settingsDef»
			
			«settingsDef»
		'''

		input.parse => [
			assertError(
				AssertXSwingPackage.eINSTANCE.AXSSettings,
				AssertXSwingValidator.TOO_MANY_SETTINGS,
				input.indexOf(settingsDef),
				settingsDef.length,
				'Too many settings definition! Settings are defined multiple times, but only one such definition is allowed'
			)
			assertError(
				AssertXSwingPackage.eINSTANCE.AXSSettings,
				AssertXSwingValidator.TOO_MANY_SETTINGS,
				input.lastIndexOf(settingsDef),
				settingsDef.length,
				'Too many settings definition! Settings are defined multiple times, but only one such definition is allowed'
			)
		]
	}

	@Test
	def void testMatchersMatchingTypeComplyWithGenericTypeMatcherTypeParameterBound() {
		val type = 'Object'

		val input = '''
			testing javax.swing.JFrame
			
			match aName : «type» {
				true
			}
		'''

		input.parse.assertError(
			AssertXSwingPackage.eINSTANCE.AXSMatcher,
			AssertXSwingValidator.UNMATCHABLE_TYPE,
			input.indexOf(type),
			type.length,
			'Unmatchable type: "java.lang.Object" is not suitable for a matcher definition, only subtypes of "java.awt.Component" can be matched'
		)
	}

	@Test
	def void testErrorOnMatchersWithSameName() {
		val name = 'aName'
		'''
			testing javax.swing.JFrame
			
			match «name» : javax.swing.JButton {
				true
			}
			
			match «name» : javax.swing.JLabel {
				true
			}
		'''.assertDuplicate(
			AssertXSwingPackage.eINSTANCE.AXSMatcher,
			name,
			"Duplicate matcher '" + name + "': matchers with same name are not permitted",
			Severity.ERROR
		)
	}
	
	@Test
	def void testNoErrorsOnTestMethodAndMatcherWithSameName(){
		'''
		testing javax.swing.JFrame
		
		match m1 : javax.swing.JLabel {
			true
		}
		
		test 'm1' {
			
		}
		'''.parse.assertNoErrors
	}

	def private void assertDuplicate(CharSequence input, EClass type, String name, String message, Severity severity) {
		input.parse => [
			assertIssue(
				type,
				AssertXSwingValidator.SAME_NAME_MEMBERS,
				input.toString.indexOf(name),
				name.length,
				severity,
				message
			)
			assertIssue(
				type,
				AssertXSwingValidator.SAME_NAME_MEMBERS,
				input.toString.lastIndexOf(name),
				name.length,
				severity,
				message
			)
		]
	}

	def private void assertAutogeneratedMethod(AXSTestCase model, String methodName, EClass type) {
		model.assertError(
			type,
			AssertXSwingValidator.AUTOGENERATED_METHOD_ACCESSED,
			'The method "' + methodName +
				'" is autogenerated from other parts of the test case definition and it is part of a fixed workflow. You cannot call it'
		)
	}

}
